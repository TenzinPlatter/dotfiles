#!/usr/bin/env python3

"""
peek - Show contents of files, directories, and archives with colored output
Supports: files, directories, tar, tar.gz, zip, 7z, gz, bz2, xz, and more
"""

import argparse
import os
import sys
import subprocess
import shutil
import tempfile
import mimetypes
from pathlib import Path
from typing import Optional, List, Tuple


# Color codes
class Color:
    RED = '\033[0;31m'
    GREEN = '\033[0;32m'
    YELLOW = '\033[1;33m'
    BLUE = '\033[0;34m'
    MAGENTA = '\033[0;35m'
    CYAN = '\033[0;36m'
    GRAY = '\033[0;90m'
    RESET = '\033[0m'


def has_cmd(cmd: str) -> bool:
    """Check if command exists."""
    return shutil.which(cmd) is not None


def filter_by_depth(files: List[str], depth: Optional[int]) -> List[str]:
    """Filter file paths by depth (number of path components)."""
    if depth is None or depth == 0:  # 0 means unlimited
        return files

    filtered = []
    for file in files:
        # Count path components (depth = number of slashes + 1)
        file_depth = file.count('/') + 1
        if file_depth <= depth:
            filtered.append(file)
    return filtered


def format_archive_tree(files: List[str], structure_only: bool) -> None:
    """Format archive file listing as a tree structure."""
    if not files:
        print(f"{Color.GRAY}(empty){Color.RESET}")
        return

    # Use tree command if available
    if has_cmd('tree'):
        with tempfile.TemporaryDirectory(prefix='peek.') as tmpdir:
            # Create directory structure
            for file in files:
                full_path = os.path.join(tmpdir, file)
                if structure_only:
                    # In structure mode, files are directories
                    os.makedirs(full_path, exist_ok=True)
                else:
                    # In normal mode, create parent dirs and touch file
                    os.makedirs(os.path.dirname(full_path), exist_ok=True)
                    Path(full_path).touch()

            # Run tree and strip tmpdir from output
            tree_opts = ['-C', '--noreport']
            if structure_only:
                tree_opts.append('-d')

            result = subprocess.run(
                ['tree'] + tree_opts + [tmpdir],
                capture_output=True,
                text=True
            )
            # Remove first line (tmpdir) and strip tmpdir path
            lines = result.stdout.split('\n')[1:]
            for line in lines:
                print(line.replace(tmpdir, ''))
    else:
        # Simple fallback - just list with indentation
        for file in sorted(files):
            depth = file.count('/')
            indent = '  ' * depth
            basename = os.path.basename(file)
            print(f"{indent}{basename}")


def peek_directory(path: str, structure_only: bool, depth: Optional[int]) -> None:
    """Display directory contents."""
    # Check if directory is empty
    try:
        if not any(os.scandir(path)):
            print(f"{Color.BLUE}üìÅ Directory:{Color.RESET} {path} {Color.GRAY}(empty){Color.RESET}")
            return
    except PermissionError:
        print(f"{Color.RED}‚ùå Error:{Color.RESET} Cannot read {path} (permission denied)", file=sys.stderr)
        return

    if structure_only:
        print(f"{Color.BLUE}üìÅ Directory structure:{Color.RESET} {path}")
    else:
        print(f"{Color.BLUE}üìÅ Directory:{Color.RESET} {path}")
    print()

    # Use depth 3 as default for directories
    tree_depth = depth if depth is not None else 3
    # Convert 0 to unlimited (999)
    if tree_depth == 0:
        tree_depth = 999

    # Try tree first (preferred for colored output)
    if has_cmd('tree'):
        tree_opts = ['-C', '-L', str(tree_depth), '--dirsfirst']
        if structure_only:
            tree_opts.append('-d')

        subprocess.run(['tree'] + tree_opts + [path])
    else:
        # Fallback to ls with color
        ls_opts = ['-lAh', '--color=auto']
        if structure_only:
            # Try to list only directories
            try:
                dirs = [d.path for d in os.scandir(path) if d.is_dir()]
                if dirs:
                    subprocess.run(['ls'] + ls_opts + dirs)
                else:
                    print(f"{Color.GRAY}(no subdirectories){Color.RESET}")
            except PermissionError:
                print(f"{Color.RED}‚ùå Error:{Color.RESET} Permission denied", file=sys.stderr)
        else:
            subprocess.run(['ls'] + ls_opts + [path])


def peek_tar(file: str, structure_only: bool, depth: Optional[int], compression: str = '') -> None:
    """Display tar archive contents."""
    format_name = f"tar{compression}" if compression else "tar"

    if structure_only:
        print(f"{Color.MAGENTA}üì¶ Archive structure:{Color.RESET} {file} {Color.GRAY}({format_name}){Color.RESET}")
    else:
        print(f"{Color.MAGENTA}üì¶ Archive:{Color.RESET} {file} {Color.GRAY}({format_name}){Color.RESET}")
    print()

    if not has_cmd('tar'):
        print(f"{Color.RED}Error:{Color.RESET} tar command not found")
        return

    # Build tar options
    tar_opts = ['-t']
    if compression == '.gz':
        tar_opts.append('z')
    elif compression == '.bz2':
        tar_opts.append('j')
    elif compression == '.xz':
        tar_opts.append('J')
    tar_opts.append('f')

    try:
        result = subprocess.run(
            ['tar'] + tar_opts + [file],
            capture_output=True,
            text=True,
            check=True
        )

        lines = result.stdout.strip().split('\n')
        if structure_only:
            # Get only directories (entries ending with /)
            files = [line.rstrip('/') for line in lines if line.endswith('/')]
        else:
            # Get only files (entries not ending with /)
            files = [line for line in lines if not line.endswith('/')]

        # Apply depth filtering with default unlimited for archives
        archive_depth = depth if depth is not None else 0
        files = filter_by_depth(files, archive_depth)

        if not files:
            if structure_only:
                print(f"{Color.GRAY}(no directories){Color.RESET}")
            else:
                print(f"{Color.GRAY}(empty or corrupted){Color.RESET}")
            return

        format_archive_tree(files, structure_only)
    except subprocess.CalledProcessError:
        print(f"{Color.GRAY}(empty or corrupted){Color.RESET}")


def peek_zip(file: str, structure_only: bool, depth: Optional[int]) -> None:
    """Display zip archive contents."""
    if structure_only:
        print(f"{Color.MAGENTA}üì¶ Archive structure:{Color.RESET} {file} {Color.GRAY}(zip){Color.RESET}")
    else:
        print(f"{Color.MAGENTA}üì¶ Archive:{Color.RESET} {file} {Color.GRAY}(zip){Color.RESET}")
    print()

    cmd = None
    if has_cmd('unzip'):
        cmd = ['unzip', '-Z1', file]
    elif has_cmd('zipinfo'):
        cmd = ['zipinfo', '-1', file]
    else:
        print(f"{Color.RED}Error:{Color.RESET} unzip or zipinfo command not found")
        return

    try:
        result = subprocess.run(cmd, capture_output=True, text=True, check=True)
        lines = result.stdout.strip().split('\n')

        if structure_only:
            files = [line.rstrip('/') for line in lines if line.endswith('/')]
        else:
            files = [line for line in lines if not line.endswith('/')]

        # Apply depth filtering with default unlimited for archives
        archive_depth = depth if depth is not None else 0
        files = filter_by_depth(files, archive_depth)

        if not files:
            if structure_only:
                print(f"{Color.GRAY}(no directories){Color.RESET}")
            else:
                print(f"{Color.GRAY}(empty or corrupted){Color.RESET}")
            return

        format_archive_tree(files, structure_only)
    except subprocess.CalledProcessError:
        print(f"{Color.GRAY}(empty or corrupted){Color.RESET}")


def peek_7z(file: str, structure_only: bool, depth: Optional[int]) -> None:
    """Display 7z archive contents."""
    if structure_only:
        print(f"{Color.MAGENTA}üì¶ Archive structure:{Color.RESET} {file} {Color.GRAY}(7z){Color.RESET}")
    else:
        print(f"{Color.MAGENTA}üì¶ Archive:{Color.RESET} {file} {Color.GRAY}(7z){Color.RESET}")
    print()

    if not has_cmd('7z'):
        print(f"{Color.RED}Error:{Color.RESET} 7z command not found")
        return

    try:
        result = subprocess.run(
            ['7z', 'l', '-ba', file],
            capture_output=True,
            text=True,
            check=True
        )

        lines = result.stdout.strip().split('\n')
        if structure_only:
            files = [line.split()[-1].rstrip('/') for line in lines if line.endswith('/')]
        else:
            files = [line.split()[-1] for line in lines if not line.endswith('/')]

        # Apply depth filtering with default unlimited for archives
        archive_depth = depth if depth is not None else 0
        files = filter_by_depth(files, archive_depth)

        if not files:
            if structure_only:
                print(f"{Color.GRAY}(no directories){Color.RESET}")
            else:
                print(f"{Color.GRAY}(empty or corrupted){Color.RESET}")
            return

        format_archive_tree(files, structure_only)
    except subprocess.CalledProcessError:
        print(f"{Color.GRAY}(empty or corrupted){Color.RESET}")


def peek_compressed(file: str, tool: str, flag: str) -> None:
    """Display compressed file contents."""
    print(f"{Color.CYAN}üóúÔ∏è  Compressed file:{Color.RESET} {file}")
    print()

    if not has_cmd(tool):
        print(f"{Color.RED}Error:{Color.RESET} {tool} command not found")
        return

    try:
        # Decompress to stdout and limit to 1MB
        result = subprocess.run(
            [tool, flag, file],
            capture_output=True,
            text=True,
            check=True
        )

        # Limit output to first 1MB
        content = result.stdout[:1024*1024]

        # Try to display with bat/batcat
        if has_cmd('bat'):
            proc = subprocess.Popen(
                ['bat', '--style=plain', '--paging=never', '--color=always'],
                stdin=subprocess.PIPE,
                text=True
            )
            proc.communicate(content)
        elif has_cmd('batcat'):
            proc = subprocess.Popen(
                ['batcat', '--style=plain', '--paging=never', '--color=always'],
                stdin=subprocess.PIPE,
                text=True
            )
            proc.communicate(content)
        else:
            print(content)
    except subprocess.CalledProcessError:
        print(f"{Color.RED}Error:{Color.RESET} Failed to decompress file")


def peek_file(file: str) -> None:
    """Display regular file contents."""
    size = subprocess.run(
        ['du', '-h', file],
        capture_output=True,
        text=True
    ).stdout.split()[0]

    print(f"{Color.BLUE}üìÑ File:{Color.RESET} {file} {Color.GRAY}({size}){Color.RESET}")
    print()

    # Try bat/batcat first for syntax highlighting
    if has_cmd('bat'):
        subprocess.run(['bat', '--style=plain', '--paging=never', '--color=always', file])
    elif has_cmd('batcat'):
        subprocess.run(['batcat', '--style=plain', '--paging=never', '--color=always', file])
    else:
        # Fallback to cat
        with open(file, 'r') as f:
            print(f.read())


def peek_binary(file: str, mime_type: str) -> None:
    """Display binary file metadata."""
    print(f"{Color.YELLOW}üîç Binary file:{Color.RESET} {file} {Color.GRAY}({mime_type}){Color.RESET}")
    print()

    # Try specialized tools based on MIME type
    if mime_type.startswith('image/'):
        if has_cmd('exiftool'):
            subprocess.run(['exiftool', file])
            return
        elif has_cmd('identify'):
            subprocess.run(['identify', '-verbose', file])
            return
    elif mime_type == 'application/pdf':
        if has_cmd('pdfinfo'):
            subprocess.run(['pdfinfo', file])
            return
        elif has_cmd('exiftool'):
            subprocess.run(['exiftool', file])
            return
    elif mime_type in ('application/x-sqlite3', 'application/vnd.sqlite3'):
        if has_cmd('sqlite3'):
            print(f"{Color.CYAN}Schema:{Color.RESET}")
            subprocess.run(['sqlite3', file, '.schema'])
            print()
            print(f"{Color.CYAN}Tables:{Color.RESET}")
            subprocess.run(['sqlite3', file, '.tables'])
            return

    # Fallback: use file command with detailed output
    result = subprocess.run(['file', '-b', file], capture_output=True, text=True)
    print(result.stdout)


def detect_and_peek(target: str, structure_only: bool, depth: Optional[int]) -> None:
    """Detect file type and route to appropriate handler."""
    path = Path(target)

    # Directory
    if path.is_dir():
        peek_directory(target, structure_only, depth)
        return

    # Get filename for extension matching
    filename = path.name.lower()

    # Archive detection (by extension, longest match first)
    if filename.endswith(('.tar.gz', '.tgz')):
        peek_tar(target, structure_only, depth, '.gz')
        return
    elif filename.endswith(('.tar.bz2', '.tbz2', '.tbz')):
        peek_tar(target, structure_only, depth, '.bz2')
        return
    elif filename.endswith(('.tar.xz', '.txz')):
        peek_tar(target, structure_only, depth, '.xz')
        return
    elif filename.endswith('.tar'):
        peek_tar(target, structure_only, depth, '')
        return
    elif filename.endswith('.zip'):
        peek_zip(target, structure_only, depth)
        return
    elif filename.endswith('.7z'):
        peek_7z(target, structure_only, depth)
        return
    elif filename.endswith('.gz'):
        peek_compressed(target, 'gzip', '-dc')
        return
    elif filename.endswith('.bz2'):
        peek_compressed(target, 'bzip2', '-dc')
        return
    elif filename.endswith('.xz'):
        peek_compressed(target, 'xz', '-dc')
        return
    elif filename.endswith('.lz4'):
        peek_compressed(target, 'lz4', '-dc')
        return
    elif filename.endswith('.zst'):
        peek_compressed(target, 'zstd', '-dc')
        return

    # MIME type detection for regular files
    result = subprocess.run(
        ['file', '--brief', '--mime-type', target],
        capture_output=True,
        text=True
    )
    mime_type = result.stdout.strip() or 'application/octet-stream'

    # Text files
    text_types = (
        'text/', 'application/json', 'application/xml',
        'application/javascript', 'application/x-sh',
        'application/x-shellscript'
    )

    if any(mime_type.startswith(t) for t in text_types):
        peek_file(target)
    else:
        peek_binary(target, mime_type)


def health_check() -> int:
    """Show available tools and capabilities."""
    exit_code = 0

    def check_tool(tool: str, description: str) -> bool:
        if has_cmd(tool):
            print(f"  {Color.GREEN}‚úì{Color.RESET} {tool}{Color.GRAY} - {description}{Color.RESET}")
            return True
        else:
            print(f"  {Color.RED}‚úó{Color.RESET} {tool}{Color.GRAY} - {description}{Color.RESET}")
            return False

    def check_multi_tool(tool1: str, tool2: str, description: str) -> bool:
        combined = f"{tool1}/{tool2}"
        if has_cmd(tool1) or has_cmd(tool2):
            print(f"  {Color.GREEN}‚úì{Color.RESET} {combined}{Color.GRAY} - {description}{Color.RESET}")
            return True
        else:
            print(f"  {Color.RED}‚úó{Color.RESET} {combined}{Color.GRAY} - {description}{Color.RESET}")
            return False

    print(f"{Color.CYAN}peek health check{Color.RESET}")
    print("=================")
    print()

    # Core utilities
    print(f"{Color.YELLOW}Core utilities{Color.RESET}")
    if not check_tool('file', 'File type detection (required)'):
        exit_code = 1
    print()

    # Enhanced viewing
    print(f"{Color.YELLOW}Enhanced viewing{Color.RESET}")
    check_multi_tool('bat', 'batcat', 'Syntax highlighting for files')
    check_tool('cat', 'Fallback for files')
    print()

    # Directory viewing
    print(f"{Color.YELLOW}Directory viewing{Color.RESET}")
    check_tool('tree', 'Colored directory tree')
    check_tool('ls', 'Fallback directory listing')
    print()

    # Archive support
    print(f"{Color.YELLOW}Archive support{Color.RESET}")
    check_tool('tar', 'TAR archives (.tar, .tar.gz, .tar.bz2, .tar.xz)')
    check_multi_tool('unzip', 'zipinfo', 'ZIP archives (.zip)')
    check_tool('7z', '7-Zip archives (.7z)')
    print()

    # Compression support
    print(f"{Color.YELLOW}Compression support{Color.RESET}")
    check_tool('gzip', '.gz files')
    check_tool('bzip2', '.bz2 files')
    check_tool('xz', '.xz files')
    check_tool('lz4', '.lz4 files')
    check_tool('zstd', '.zst files')
    print()

    # Binary file inspection
    print(f"{Color.YELLOW}Binary file inspection{Color.RESET}")
    check_tool('exiftool', 'Image/PDF metadata')
    check_tool('identify', 'ImageMagick image info')
    check_tool('sqlite3', 'SQLite database inspection')
    check_tool('pdfinfo', 'PDF information')
    print()

    print(f"{Color.GRAY}Legend: {Color.GREEN}‚úì{Color.GRAY} available  {Color.RED}‚úó{Color.GRAY} not found{Color.RESET}")

    return exit_code


def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(
        description='Show contents of files, directories, and archives with colored output.',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog='''
Supported formats:
  - Regular files (with syntax highlighting via bat)
  - Directories (tree view)
  - Archives: tar, tar.gz, tar.bz2, tar.xz, zip, 7z
  - Compressed: .gz, .bz2, .xz, .lz4, .zst
  - Binary files (metadata via specialized tools)

Examples:
  peek README.md
  peek src/
  peek -s src/                # Show only directory structure
  peek -d 1 src/              # Show only top level
  peek archive.tar.gz
  peek -s -d 2 archive.tar.gz # Show only directories, depth 2
        '''
    )

    parser.add_argument('path', nargs='?', help='Path to file, directory, or archive')
    parser.add_argument('-s', '--structure', action='store_true',
                        help='Structure only (directories only, no files)')
    parser.add_argument('-d', '--depth', type=int, metavar='N',
                        help='Limit depth to N levels (0 for unlimited)')
    parser.add_argument('--health', action='store_true',
                        help='Show available tools and capabilities')

    args = parser.parse_args()

    # Health check
    if args.health:
        sys.exit(health_check())

    # Need a path
    if not args.path:
        parser.print_help()
        sys.exit(0)

    target = args.path

    # Check if path exists
    if not os.path.exists(target):
        print(f"{Color.RED}‚ùå Error:{Color.RESET} {target} not found", file=sys.stderr)
        sys.exit(1)

    # Check if readable
    if not os.access(target, os.R_OK):
        print(f"{Color.RED}‚ùå Error:{Color.RESET} Cannot read {target} (permission denied)", file=sys.stderr)
        sys.exit(1)

    # Handle symlinks
    if os.path.islink(target):
        real_target = os.path.realpath(target)
        print(f"{Color.CYAN}‚Üí Following symlink to:{Color.RESET} {real_target}")
        target = real_target

    # Detect and peek
    detect_and_peek(target, args.structure, args.depth)


if __name__ == '__main__':
    main()
