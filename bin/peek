#!/usr/bin/env bash

# peek - Show contents of files, directories, and archives with colored output
# Supports: files, directories, tar, tar.gz, zip, 7z, gz, bz2, xz, and more

set -euo pipefail

# Color codes
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
CYAN='\033[0;36m'
GRAY='\033[0;90m'
RESET='\033[0m'

# Utility function to check if command exists
has_cmd() {
    command -v "$1" &> /dev/null
}

# Show usage message
show_usage() {
    echo -e "${CYAN}Usage:${RESET} peek <path>"
    echo ""
    echo "Shows contents of files, directories, and archives with colored output."
    echo ""
    echo -e "${CYAN}Supported formats:${RESET}"
    echo "  - Regular files (with syntax highlighting via bat)"
    echo "  - Directories (tree view)"
    echo "  - Archives: tar, tar.gz, tar.bz2, tar.xz, zip, 7z"
    echo "  - Compressed: .gz, .bz2, .xz, .lz4, .zst"
    echo "  - Binary files (metadata via specialized tools)"
    echo ""
    echo -e "${CYAN}Options:${RESET}"
    echo "  -s          Structure only (directories only, no files)"
    echo "  --health    Show available tools and capabilities"
    echo ""
    echo -e "${CYAN}Examples:${RESET}"
    echo "  peek README.md"
    echo "  peek src/"
    echo "  peek -s src/                # Show only directory structure"
    echo "  peek archive.tar.gz"
    echo "  peek -s archive.tar.gz      # Show only directories in archive"
}

# Main dispatcher
main() {
    # Parse arguments
    if [[ $# -eq 0 ]]; then
        show_usage
        exit 0
    fi

    if [[ "$1" == "--health" ]] || [[ "$1" == "health" ]]; then
        health_check
        exit $?
    fi

    if [[ "$1" == "-h" ]] || [[ "$1" == "--help" ]]; then
        show_usage
        exit 0
    fi

    # Parse flags
    local structure_only=false
    local target=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -s)
                structure_only=true
                shift
                ;;
            *)
                target="$1"
                shift
                ;;
        esac
    done

    # Check if target was provided
    if [[ -z "$target" ]]; then
        show_usage
        exit 1
    fi

    # Check if path exists
    if [[ ! -e "$target" ]]; then
        echo -e "${RED}âŒ Error:${RESET} $target not found" >&2
        exit 1
    fi

    # Check if readable
    if [[ ! -r "$target" ]]; then
        echo -e "${RED}âŒ Error:${RESET} Cannot read $target (permission denied)" >&2
        exit 1
    fi

    # Handle symlinks
    if [[ -L "$target" ]]; then
        local real_target
        real_target=$(readlink -f "$target")
        echo -e "${CYAN}â†’ Following symlink to:${RESET} $real_target"
        target="$real_target"
    fi

    # Detect and dispatch
    detect_and_peek "$target" "$structure_only"
}

# Detect file type and route to appropriate handler
detect_and_peek() {
    local target="$1"
    local structure_only="$2"

    # Directory
    if [[ -d "$target" ]]; then
        peek_directory "$target" "$structure_only"
        return
    fi

    # Get filename for extension matching
    local filename
    filename=$(basename "$target")

    # Archive detection (by extension, longest match first)
    case "$filename" in
        *.tar.gz|*.tgz)
            peek_tar_gz "$target" "$structure_only"
            return
            ;;
        *.tar.bz2|*.tbz2|*.tbz)
            peek_tar_bz2 "$target" "$structure_only"
            return
            ;;
        *.tar.xz|*.txz)
            peek_tar_xz "$target" "$structure_only"
            return
            ;;
        *.tar)
            peek_tar "$target" "$structure_only"
            return
            ;;
        *.zip)
            peek_zip "$target" "$structure_only"
            return
            ;;
        *.7z)
            peek_7z "$target" "$structure_only"
            return
            ;;
        *.gz)
            peek_compressed "$target" "gzip" "-dc"
            return
            ;;
        *.bz2)
            peek_compressed "$target" "bzip2" "-dc"
            return
            ;;
        *.xz)
            peek_compressed "$target" "xz" "-dc"
            return
            ;;
        *.lz4)
            peek_compressed "$target" "lz4" "-dc"
            return
            ;;
        *.zst)
            peek_compressed "$target" "zstd" "-dc"
            return
            ;;
    esac

    # MIME type detection for regular files
    local mime_type
    mime_type=$(file --brief --mime-type "$target" 2>/dev/null || echo "application/octet-stream")

    case "$mime_type" in
        text/*|application/json|application/xml|application/javascript|application/x-sh|application/x-shellscript)
            peek_file "$target"
            ;;
        *)
            peek_binary "$target" "$mime_type"
            ;;
    esac
}

# Health check - show available tools
health_check() {
    local exit_code=0

    echo -e "${CYAN}peek health check${RESET}"
    echo "================="
    echo ""

    # Core utilities
    echo -e "${YELLOW}Core utilities${RESET}"
    check_tool "file" "File type detection (required)" || exit_code=1
    check_tool "test" "Path validation (required)" || exit_code=1
    echo ""

    # Enhanced viewing
    echo -e "${YELLOW}Enhanced viewing${RESET}"
    check_multi_tool "bat" "batcat" "Syntax highlighting for files" || true
    check_tool "cat" "Fallback for files" || true
    echo ""

    # Directory viewing
    echo -e "${YELLOW}Directory viewing${RESET}"
    check_tool "tree" "Colored directory tree" || true
    check_tool "ls" "Fallback directory listing" || true
    echo ""

    # Archive support
    echo -e "${YELLOW}Archive support${RESET}"
    check_tool "tar" "TAR archives (.tar, .tar.gz, .tar.bz2, .tar.xz)" || true
    check_multi_tool "unzip" "zipinfo" "ZIP archives (.zip)" || true
    check_tool "7z" "7-Zip archives (.7z)" || true
    echo ""

    # Compression support
    echo -e "${YELLOW}Compression support${RESET}"
    check_tool "gzip" ".gz files" || true
    check_tool "bzip2" ".bz2 files" || true
    check_tool "xz" ".xz files" || true
    check_tool "lz4" ".lz4 files" || true
    check_tool "zstd" ".zst files" || true
    echo ""

    # Binary file inspection
    echo -e "${YELLOW}Binary file inspection${RESET}"
    check_tool "exiftool" "Image/PDF metadata" || true
    check_tool "identify" "ImageMagick image info" || true
    check_tool "sqlite3" "SQLite database inspection" || true
    check_tool "pdfinfo" "PDF information" || true
    echo ""

    echo -e "${GRAY}Legend: ${GREEN}âœ“${GRAY} available  ${RED}âœ—${GRAY} not found  ${YELLOW}âš ${GRAY} issue${RESET}"

    return $exit_code
}

# Check if a tool is available
check_tool() {
    local tool="$1"
    local description="$2"

    if has_cmd "$tool"; then
        echo -e "  ${GREEN}âœ“${RESET} ${tool}${GRAY} - ${description}${RESET}"
        return 0
    else
        echo -e "  ${RED}âœ—${RESET} ${tool}${GRAY} - ${description}${RESET}"
        return 1
    fi
}

# Check if at least one of multiple tools is available
check_multi_tool() {
    local tool1="$1"
    local tool2="$2"
    local description="$3"
    local combined="${tool1}/${tool2}"

    if has_cmd "$tool1" || has_cmd "$tool2"; then
        echo -e "  ${GREEN}âœ“${RESET} ${combined}${GRAY} - ${description}${RESET}"
        return 0
    else
        echo -e "  ${RED}âœ—${RESET} ${combined}${GRAY} - ${description}${RESET}"
        return 1
    fi
}

peek_directory() {
    local dir="$1"
    local structure_only="$2"

    # Check if directory is empty
    if [[ -z "$(ls -A "$dir" 2>/dev/null)" ]]; then
        echo -e "${BLUE}ðŸ“ Directory:${RESET} $dir ${GRAY}(empty)${RESET}"
        return 0
    fi

    if [[ "$structure_only" == "true" ]]; then
        echo -e "${BLUE}ðŸ“ Directory structure:${RESET} $dir"
    else
        echo -e "${BLUE}ðŸ“ Directory:${RESET} $dir"
    fi
    echo ""

    # Try tree first (preferred for colored output)
    if has_cmd "tree"; then
        if [[ "$structure_only" == "true" ]]; then
            tree -C -L 3 -d --dirsfirst "$dir"
        else
            tree -C -L 3 --dirsfirst "$dir"
        fi
    else
        # Fallback to ls with color
        if [[ "$structure_only" == "true" ]]; then
            ls -lAhd --color=auto "$dir"/*/ 2>/dev/null || echo -e "${GRAY}(no subdirectories)${RESET}"
        else
            ls -lAh --color=auto "$dir"
        fi
    fi
}

# Helper function to format archive listing as tree
format_archive_tree() {
    local structure_only="$1"
    shift
    local files=("$@")

    if [[ ${#files[@]} -eq 0 ]]; then
        echo -e "${GRAY}(empty)${RESET}"
        return
    fi

    # Use tree command if available
    if has_cmd "tree"; then
        # Create temp dir and structure, then tree it
        local tmpdir
        tmpdir=$(mktemp -d -t peek.XXXXXXXXXX)
        trap 'rm -rf "$tmpdir"' RETURN

        for file in "${files[@]}"; do
            if [[ "$structure_only" == "true" ]]; then
                # In structure mode, files are directories
                mkdir -p "$tmpdir/$file"
            else
                # In normal mode, files are files
                local dir=$(dirname "$tmpdir/$file")
                mkdir -p "$dir"
                touch "$tmpdir/$file"
            fi
        done

        if [[ "$structure_only" == "true" ]]; then
            tree -C -d --noreport "$tmpdir" | tail -n +2 | sed 's|'"$tmpdir"'||g'
        else
            tree -C --noreport "$tmpdir" | tail -n +2 | sed 's|'"$tmpdir"'||g'
        fi
    else
        # Simple fallback - just list with indentation
        printf '%s\n' "${files[@]}" | sort | while read -r file; do
            local depth=$(echo "$file" | grep -o "/" | wc -l)
            local indent=$(printf '%*s' $((depth * 2)) '')
            local basename=$(basename "$file")
            echo "${indent}${basename}"
        done
    fi
}

peek_tar() {
    local file="$1"
    local structure_only="$2"

    if [[ "$structure_only" == "true" ]]; then
        echo -e "${MAGENTA}ðŸ“¦ Archive structure:${RESET} $file ${GRAY}(tar)${RESET}"
    else
        echo -e "${MAGENTA}ðŸ“¦ Archive:${RESET} $file ${GRAY}(tar)${RESET}"
    fi
    echo ""

    if ! has_cmd "tar"; then
        echo -e "${RED}Error:${RESET} tar command not found"
        return 1
    fi

    local files
    if [[ "$structure_only" == "true" ]]; then
        mapfile -t files < <(tar -tf "$file" 2>/dev/null | grep '/$' | sed 's|/$||' || true)
    else
        mapfile -t files < <(tar -tf "$file" 2>/dev/null | grep -v '/$' || true)
    fi

    if [[ ${#files[@]} -eq 0 ]]; then
        if [[ "$structure_only" == "true" ]]; then
            echo -e "${GRAY}(no directories)${RESET}"
        else
            echo -e "${GRAY}(empty or corrupted)${RESET}"
        fi
        return 0
    fi

    format_archive_tree "$structure_only" "${files[@]}"
}

peek_tar_gz() {
    local file="$1"
    local structure_only="$2"

    if [[ "$structure_only" == "true" ]]; then
        echo -e "${MAGENTA}ðŸ“¦ Archive structure:${RESET} $file ${GRAY}(tar.gz)${RESET}"
    else
        echo -e "${MAGENTA}ðŸ“¦ Archive:${RESET} $file ${GRAY}(tar.gz)${RESET}"
    fi
    echo ""

    if ! has_cmd "tar"; then
        echo -e "${RED}Error:${RESET} tar command not found"
        return 1
    fi

    local files
    if [[ "$structure_only" == "true" ]]; then
        mapfile -t files < <(tar -tzf "$file" 2>/dev/null | grep '/$' | sed 's|/$||' || true)
    else
        mapfile -t files < <(tar -tzf "$file" 2>/dev/null | grep -v '/$' || true)
    fi

    if [[ ${#files[@]} -eq 0 ]]; then
        if [[ "$structure_only" == "true" ]]; then
            echo -e "${GRAY}(no directories)${RESET}"
        else
            echo -e "${GRAY}(empty or corrupted)${RESET}"
        fi
        return 0
    fi

    format_archive_tree "$structure_only" "${files[@]}"
}

peek_tar_bz2() {
    local file="$1"
    local structure_only="$2"

    if [[ "$structure_only" == "true" ]]; then
        echo -e "${MAGENTA}ðŸ“¦ Archive structure:${RESET} $file ${GRAY}(tar.bz2)${RESET}"
    else
        echo -e "${MAGENTA}ðŸ“¦ Archive:${RESET} $file ${GRAY}(tar.bz2)${RESET}"
    fi
    echo ""

    if ! has_cmd "tar"; then
        echo -e "${RED}Error:${RESET} tar command not found"
        return 1
    fi

    local files
    if [[ "$structure_only" == "true" ]]; then
        mapfile -t files < <(tar -tjf "$file" 2>/dev/null | grep '/$' | sed 's|/$||' || true)
    else
        mapfile -t files < <(tar -tjf "$file" 2>/dev/null | grep -v '/$' || true)
    fi

    if [[ ${#files[@]} -eq 0 ]]; then
        if [[ "$structure_only" == "true" ]]; then
            echo -e "${GRAY}(no directories)${RESET}"
        else
            echo -e "${GRAY}(empty or corrupted)${RESET}"
        fi
        return 0
    fi

    format_archive_tree "$structure_only" "${files[@]}"
}

peek_tar_xz() {
    local file="$1"
    local structure_only="$2"

    if [[ "$structure_only" == "true" ]]; then
        echo -e "${MAGENTA}ðŸ“¦ Archive structure:${RESET} $file ${GRAY}(tar.xz)${RESET}"
    else
        echo -e "${MAGENTA}ðŸ“¦ Archive:${RESET} $file ${GRAY}(tar.xz)${RESET}"
    fi
    echo ""

    if ! has_cmd "tar"; then
        echo -e "${RED}Error:${RESET} tar command not found"
        return 1
    fi

    local files
    if [[ "$structure_only" == "true" ]]; then
        mapfile -t files < <(tar -tJf "$file" 2>/dev/null | grep '/$' | sed 's|/$||' || true)
    else
        mapfile -t files < <(tar -tJf "$file" 2>/dev/null | grep -v '/$' || true)
    fi

    if [[ ${#files[@]} -eq 0 ]]; then
        if [[ "$structure_only" == "true" ]]; then
            echo -e "${GRAY}(no directories)${RESET}"
        else
            echo -e "${GRAY}(empty or corrupted)${RESET}"
        fi
        return 0
    fi

    format_archive_tree "$structure_only" "${files[@]}"
}

peek_zip() {
    local file="$1"
    local structure_only="$2"

    if [[ "$structure_only" == "true" ]]; then
        echo -e "${MAGENTA}ðŸ“¦ Archive structure:${RESET} $file ${GRAY}(zip)${RESET}"
    else
        echo -e "${MAGENTA}ðŸ“¦ Archive:${RESET} $file ${GRAY}(zip)${RESET}"
    fi
    echo ""

    local files
    if has_cmd "unzip"; then
        if [[ "$structure_only" == "true" ]]; then
            mapfile -t files < <(unzip -Z1 "$file" 2>/dev/null | grep '/$' | sed 's|/$||' || true)
        else
            mapfile -t files < <(unzip -Z1 "$file" 2>/dev/null | grep -v '/$' || true)
        fi
    elif has_cmd "zipinfo"; then
        if [[ "$structure_only" == "true" ]]; then
            mapfile -t files < <(zipinfo -1 "$file" 2>/dev/null | grep '/$' | sed 's|/$||' || true)
        else
            mapfile -t files < <(zipinfo -1 "$file" 2>/dev/null | grep -v '/$' || true)
        fi
    else
        echo -e "${RED}Error:${RESET} unzip or zipinfo command not found"
        return 1
    fi

    if [[ ${#files[@]} -eq 0 ]]; then
        if [[ "$structure_only" == "true" ]]; then
            echo -e "${GRAY}(no directories)${RESET}"
        else
            echo -e "${GRAY}(empty or corrupted)${RESET}"
        fi
        return 0
    fi

    format_archive_tree "$structure_only" "${files[@]}"
}

peek_7z() {
    local file="$1"
    local structure_only="$2"

    if [[ "$structure_only" == "true" ]]; then
        echo -e "${MAGENTA}ðŸ“¦ Archive structure:${RESET} $file ${GRAY}(7z)${RESET}"
    else
        echo -e "${MAGENTA}ðŸ“¦ Archive:${RESET} $file ${GRAY}(7z)${RESET}"
    fi
    echo ""

    if ! has_cmd "7z"; then
        echo -e "${RED}Error:${RESET} 7z command not found"
        return 1
    fi

    local files
    if [[ "$structure_only" == "true" ]]; then
        mapfile -t files < <(7z l -ba "$file" 2>/dev/null | grep '/$' | sed 's|/$||' | awk '{print $NF}' || true)
    else
        mapfile -t files < <(7z l -ba "$file" 2>/dev/null | grep -v '/$' | awk '{print $NF}' || true)
    fi

    if [[ ${#files[@]} -eq 0 ]]; then
        if [[ "$structure_only" == "true" ]]; then
            echo -e "${GRAY}(no directories)${RESET}"
        else
            echo -e "${GRAY}(empty or corrupted)${RESET}"
        fi
        return 0
    fi

    format_archive_tree "$structure_only" "${files[@]}"
}

peek_compressed() {
    local file="$1"
    local tool="$2"
    local flag="$3"

    echo -e "${CYAN}ðŸ—œï¸  Compressed file:${RESET} $file"
    echo ""

    if ! has_cmd "$tool"; then
        echo -e "${RED}Error:${RESET} $tool command not found"
        return 1
    fi

    # Decompress to stdout and display
    if "$tool" "$flag" "$file" 2>/dev/null | head -c 1M > /tmp/peek_decompressed_$$; then
        # Try to display with bat/cat
        if has_cmd "bat"; then
            bat --style=plain --paging=never --color=always /tmp/peek_decompressed_$$
        elif has_cmd "batcat"; then
            batcat --style=plain --paging=never --color=always /tmp/peek_decompressed_$$
        else
            cat /tmp/peek_decompressed_$$
        fi
        rm -f /tmp/peek_decompressed_$$
    else
        echo -e "${RED}Error:${RESET} Failed to decompress file"
        rm -f /tmp/peek_decompressed_$$
        return 1
    fi
}

peek_file() {
    local file="$1"
    local size
    size=$(du -h "$file" 2>/dev/null | cut -f1)

    echo -e "${BLUE}ðŸ“„ File:${RESET} $file ${GRAY}($size)${RESET}"
    echo ""

    # Try bat/batcat first for syntax highlighting
    if has_cmd "bat"; then
        bat --style=plain --paging=never --color=always "$file"
    elif has_cmd "batcat"; then
        batcat --style=plain --paging=never --color=always "$file"
    else
        # Fallback to cat
        cat "$file"
    fi
}

peek_binary() {
    local file="$1"
    local mime_type="$2"

    echo -e "${YELLOW}ðŸ” Binary file:${RESET} $file ${GRAY}($mime_type)${RESET}"
    echo ""

    # Try specialized tools based on MIME type
    case "$mime_type" in
        image/*)
            if has_cmd "exiftool"; then
                exiftool "$file"
                return 0
            elif has_cmd "identify"; then
                identify -verbose "$file"
                return 0
            fi
            ;;
        application/pdf)
            if has_cmd "pdfinfo"; then
                pdfinfo "$file"
                return 0
            elif has_cmd "exiftool"; then
                exiftool "$file"
                return 0
            fi
            ;;
        application/x-sqlite3|application/vnd.sqlite3)
            if has_cmd "sqlite3"; then
                echo -e "${CYAN}Schema:${RESET}"
                sqlite3 "$file" ".schema" 2>/dev/null || echo -e "${RED}Failed to read SQLite database${RESET}"
                echo ""
                echo -e "${CYAN}Tables:${RESET}"
                sqlite3 "$file" ".tables" 2>/dev/null || true
                return 0
            fi
            ;;
    esac

    # Fallback: use file command with detailed output
    file -b "$file"
}

# Run main
main "$@"
