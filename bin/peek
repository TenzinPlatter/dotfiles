#!/usr/bin/env bash

# peek - Show contents of files, directories, and archives with colored output
# Supports: files, directories, tar, tar.gz, zip, 7z, gz, bz2, xz, and more

set -euo pipefail

# Color codes
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
CYAN='\033[0;36m'
GRAY='\033[0;90m'
RESET='\033[0m'

# Utility function to check if command exists
has_cmd() {
    command -v "$1" &> /dev/null
}

# Show usage message
show_usage() {
    cat << EOF
${CYAN}Usage:${RESET} peek <path>

Shows contents of files, directories, and archives with colored output.

${CYAN}Supported formats:${RESET}
  - Regular files (with syntax highlighting via bat)
  - Directories (tree view)
  - Archives: tar, tar.gz, tar.bz2, tar.xz, zip, 7z
  - Compressed: .gz, .bz2, .xz, .lz4, .zst
  - Binary files (metadata via specialized tools)

${CYAN}Options:${RESET}
  --health    Show available tools and capabilities

${CYAN}Examples:${RESET}
  peek README.md
  peek src/
  peek archive.tar.gz
  peek data.json.gz
EOF
}

# Main dispatcher
main() {
    # Parse arguments
    if [[ $# -eq 0 ]]; then
        show_usage
        exit 0
    fi

    if [[ "$1" == "--health" ]] || [[ "$1" == "health" ]]; then
        health_check
        exit $?
    fi

    if [[ "$1" == "-h" ]] || [[ "$1" == "--help" ]]; then
        show_usage
        exit 0
    fi

    local target="$1"

    # Check if path exists
    if [[ ! -e "$target" ]]; then
        echo -e "${RED}‚ùå Error:${RESET} $target not found" >&2
        exit 1
    fi

    # Check if readable
    if [[ ! -r "$target" ]]; then
        echo -e "${RED}‚ùå Error:${RESET} Cannot read $target (permission denied)" >&2
        exit 1
    fi

    # Handle symlinks
    if [[ -L "$target" ]]; then
        local real_target
        real_target=$(readlink -f "$target")
        echo -e "${CYAN}‚Üí Following symlink to:${RESET} $real_target"
        target="$real_target"
    fi

    # Detect and dispatch
    detect_and_peek "$target"
}

# Detect file type and route to appropriate handler
detect_and_peek() {
    local target="$1"

    # Directory
    if [[ -d "$target" ]]; then
        peek_directory "$target"
        return
    fi

    # Get filename for extension matching
    local filename
    filename=$(basename "$target")

    # Archive detection (by extension, longest match first)
    case "$filename" in
        *.tar.gz|*.tgz)
            peek_tar_gz "$target"
            return
            ;;
        *.tar.bz2|*.tbz2|*.tbz)
            peek_tar_bz2 "$target"
            return
            ;;
        *.tar.xz|*.txz)
            peek_tar_xz "$target"
            return
            ;;
        *.tar)
            peek_tar "$target"
            return
            ;;
        *.zip)
            peek_zip "$target"
            return
            ;;
        *.7z)
            peek_7z "$target"
            return
            ;;
        *.gz)
            peek_compressed "$target" "gzip" "-dc"
            return
            ;;
        *.bz2)
            peek_compressed "$target" "bzip2" "-dc"
            return
            ;;
        *.xz)
            peek_compressed "$target" "xz" "-dc"
            return
            ;;
        *.lz4)
            peek_compressed "$target" "lz4" "-dc"
            return
            ;;
        *.zst)
            peek_compressed "$target" "zstd" "-dc"
            return
            ;;
    esac

    # MIME type detection for regular files
    local mime_type
    mime_type=$(file --brief --mime-type "$target" 2>/dev/null || echo "application/octet-stream")

    case "$mime_type" in
        text/*|application/json|application/xml|application/javascript|application/x-sh|application/x-shellscript)
            peek_file "$target"
            ;;
        *)
            peek_binary "$target" "$mime_type"
            ;;
    esac
}

# Health check - show available tools
health_check() {
    local exit_code=0

    echo -e "${CYAN}peek health check${RESET}"
    echo "================="
    echo ""

    # Core utilities
    echo -e "${YELLOW}Core utilities${RESET}"
    check_tool "file" "File type detection (required)" && true || exit_code=1
    check_tool "test" "Path validation (required)" && true || exit_code=1
    echo ""

    # Enhanced viewing
    echo -e "${YELLOW}Enhanced viewing${RESET}"
    check_multi_tool "bat" "batcat" "Syntax highlighting for files"
    check_tool "cat" "Fallback for files"
    echo ""

    # Directory viewing
    echo -e "${YELLOW}Directory viewing${RESET}"
    check_tool "tree" "Colored directory tree"
    check_tool "ls" "Fallback directory listing"
    echo ""

    # Archive support
    echo -e "${YELLOW}Archive support${RESET}"
    check_tool "tar" "TAR archives (.tar, .tar.gz, .tar.bz2, .tar.xz)"
    check_multi_tool "unzip" "zipinfo" "ZIP archives (.zip)"
    check_tool "7z" "7-Zip archives (.7z)"
    echo ""

    # Compression support
    echo -e "${YELLOW}Compression support${RESET}"
    check_tool "gzip" ".gz files"
    check_tool "bzip2" ".bz2 files"
    check_tool "xz" ".xz files"
    check_tool "lz4" ".lz4 files"
    check_tool "zstd" ".zst files"
    echo ""

    # Binary file inspection
    echo -e "${YELLOW}Binary file inspection${RESET}"
    check_tool "exiftool" "Image/PDF metadata"
    check_tool "identify" "ImageMagick image info"
    check_tool "sqlite3" "SQLite database inspection"
    check_tool "pdfinfo" "PDF information"
    echo ""

    echo -e "${GRAY}Legend: ${GREEN}‚úì${GRAY} available  ${RED}‚úó${GRAY} not found  ${YELLOW}‚ö†${GRAY} issue${RESET}"

    return $exit_code
}

# Check if a tool is available
check_tool() {
    local tool="$1"
    local description="$2"

    if has_cmd "$tool"; then
        echo -e "  ${GREEN}‚úì${RESET} ${tool}${GRAY} - ${description}${RESET}"
        return 0
    else
        echo -e "  ${RED}‚úó${RESET} ${tool}${GRAY} - ${description}${RESET}"
        return 1
    fi
}

# Check if at least one of multiple tools is available
check_multi_tool() {
    local tool1="$1"
    local tool2="$2"
    local description="$3"
    local combined="${tool1}/${tool2}"

    if has_cmd "$tool1" || has_cmd "$tool2"; then
        echo -e "  ${GREEN}‚úì${RESET} ${combined}${GRAY} - ${description}${RESET}"
        return 0
    else
        echo -e "  ${RED}‚úó${RESET} ${combined}${GRAY} - ${description}${RESET}"
        return 1
    fi
}

peek_directory() {
    local dir="$1"

    # Check if directory is empty
    if [[ -z "$(ls -A "$dir" 2>/dev/null)" ]]; then
        echo -e "${BLUE}üìÅ Directory:${RESET} $dir ${GRAY}(empty)${RESET}"
        return 0
    fi

    echo -e "${BLUE}üìÅ Directory:${RESET} $dir"
    echo ""

    # Try tree first (preferred for colored output)
    if has_cmd "tree"; then
        tree -C -L 3 --dirsfirst "$dir"
    else
        # Fallback to ls with color
        ls -lAh --color=auto "$dir"
    fi
}

# Helper function to format archive listing as tree
format_archive_tree() {
    local files=("$@")

    if [[ ${#files[@]} -eq 0 ]]; then
        echo -e "${GRAY}(empty)${RESET}"
        return
    fi

    # Use tree command if available
    if has_cmd "tree"; then
        # Create temp dir and structure, then tree it
        local tmpdir
        tmpdir=$(mktemp -d)
        trap 'rm -rf "$tmpdir"' RETURN

        for file in "${files[@]}"; do
            local dir=$(dirname "$tmpdir/$file")
            mkdir -p "$dir"
            touch "$tmpdir/$file"
        done

        tree -C --noreport "$tmpdir" | tail -n +2 | sed 's|'"$tmpdir"'||g'
        rm -rf "$tmpdir"
    else
        # Simple fallback - just list with indentation
        printf '%s\n' "${files[@]}" | sort | while read -r file; do
            local depth=$(echo "$file" | grep -o "/" | wc -l)
            local indent=$(printf '%*s' $((depth * 2)) '')
            local basename=$(basename "$file")
            echo "${indent}${basename}"
        done
    fi
}

peek_tar() {
    local file="$1"
    echo -e "${MAGENTA}üì¶ Archive:${RESET} $file ${GRAY}(tar)${RESET}"
    echo ""

    if ! has_cmd "tar"; then
        echo -e "${RED}Error:${RESET} tar command not found"
        return 1
    fi

    local files
    mapfile -t files < <(tar -tf "$file" 2>/dev/null | grep -v '/$' || true)

    if [[ ${#files[@]} -eq 0 ]]; then
        echo -e "${GRAY}(empty or corrupted)${RESET}"
        return 0
    fi

    format_archive_tree "${files[@]}"
}

peek_tar_gz() {
    local file="$1"
    echo -e "${MAGENTA}üì¶ Archive:${RESET} $file ${GRAY}(tar.gz)${RESET}"
    echo ""

    if ! has_cmd "tar"; then
        echo -e "${RED}Error:${RESET} tar command not found"
        return 1
    fi

    local files
    mapfile -t files < <(tar -tzf "$file" 2>/dev/null | grep -v '/$' || true)

    if [[ ${#files[@]} -eq 0 ]]; then
        echo -e "${GRAY}(empty or corrupted)${RESET}"
        return 0
    fi

    format_archive_tree "${files[@]}"
}

peek_tar_bz2() {
    local file="$1"
    echo -e "${MAGENTA}üì¶ Archive:${RESET} $file ${GRAY}(tar.bz2)${RESET}"
    echo ""

    if ! has_cmd "tar"; then
        echo -e "${RED}Error:${RESET} tar command not found"
        return 1
    fi

    local files
    mapfile -t files < <(tar -tjf "$file" 2>/dev/null | grep -v '/$' || true)

    if [[ ${#files[@]} -eq 0 ]]; then
        echo -e "${GRAY}(empty or corrupted)${RESET}"
        return 0
    fi

    format_archive_tree "${files[@]}"
}

peek_tar_xz() {
    local file="$1"
    echo -e "${MAGENTA}üì¶ Archive:${RESET} $file ${GRAY}(tar.xz)${RESET}"
    echo ""

    if ! has_cmd "tar"; then
        echo -e "${RED}Error:${RESET} tar command not found"
        return 1
    fi

    local files
    mapfile -t files < <(tar -tJf "$file" 2>/dev/null | grep -v '/$' || true)

    if [[ ${#files[@]} -eq 0 ]]; then
        echo -e "${GRAY}(empty or corrupted)${RESET}"
        return 0
    fi

    format_archive_tree "${files[@]}"
}

peek_zip() {
    local file="$1"
    echo -e "${MAGENTA}üì¶ Archive:${RESET} $file ${GRAY}(zip)${RESET}"
    echo ""

    local files
    if has_cmd "unzip"; then
        mapfile -t files < <(unzip -Z1 "$file" 2>/dev/null | grep -v '/$' || true)
    elif has_cmd "zipinfo"; then
        mapfile -t files < <(zipinfo -1 "$file" 2>/dev/null | grep -v '/$' || true)
    else
        echo -e "${RED}Error:${RESET} unzip or zipinfo command not found"
        return 1
    fi

    if [[ ${#files[@]} -eq 0 ]]; then
        echo -e "${GRAY}(empty or corrupted)${RESET}"
        return 0
    fi

    format_archive_tree "${files[@]}"
}

peek_7z() {
    local file="$1"
    echo -e "${MAGENTA}üì¶ Archive:${RESET} $file ${GRAY}(7z)${RESET}"
    echo ""

    if ! has_cmd "7z"; then
        echo -e "${RED}Error:${RESET} 7z command not found"
        return 1
    fi

    local files
    mapfile -t files < <(7z l -ba "$file" 2>/dev/null | grep -v '/$' | awk '{print $NF}' || true)

    if [[ ${#files[@]} -eq 0 ]]; then
        echo -e "${GRAY}(empty or corrupted)${RESET}"
        return 0
    fi

    format_archive_tree "${files[@]}"
}

peek_compressed() {
    local file="$1"
    local tool="$2"
    local flag="$3"

    echo -e "${CYAN}üóúÔ∏è  Compressed file:${RESET} $file"
    echo ""

    if ! has_cmd "$tool"; then
        echo -e "${RED}Error:${RESET} $tool command not found"
        return 1
    fi

    # Decompress to stdout and display
    if "$tool" "$flag" "$file" 2>/dev/null | head -c 1M > /tmp/peek_decompressed_$$; then
        # Try to display with bat/cat
        if has_cmd "bat"; then
            bat --style=plain --paging=never --color=always /tmp/peek_decompressed_$$
        elif has_cmd "batcat"; then
            batcat --style=plain --paging=never --color=always /tmp/peek_decompressed_$$
        else
            cat /tmp/peek_decompressed_$$
        fi
        rm -f /tmp/peek_decompressed_$$
    else
        echo -e "${RED}Error:${RESET} Failed to decompress file"
        rm -f /tmp/peek_decompressed_$$
        return 1
    fi
}

peek_file() {
    local file="$1"
    local size
    size=$(du -h "$file" 2>/dev/null | cut -f1)

    echo -e "${BLUE}üìÑ File:${RESET} $file ${GRAY}($size)${RESET}"
    echo ""

    # Try bat/batcat first for syntax highlighting
    if has_cmd "bat"; then
        bat --style=plain --paging=never --color=always "$file"
    elif has_cmd "batcat"; then
        batcat --style=plain --paging=never --color=always "$file"
    else
        # Fallback to cat
        cat "$file"
    fi
}

peek_binary() {
    local file="$1"
    local mime_type="$2"

    echo -e "${YELLOW}üîç Binary file:${RESET} $file ${GRAY}($mime_type)${RESET}"
    echo ""

    # Try specialized tools based on MIME type
    case "$mime_type" in
        image/*)
            if has_cmd "exiftool"; then
                exiftool "$file"
                return 0
            elif has_cmd "identify"; then
                identify -verbose "$file"
                return 0
            fi
            ;;
        application/pdf)
            if has_cmd "pdfinfo"; then
                pdfinfo "$file"
                return 0
            elif has_cmd "exiftool"; then
                exiftool "$file"
                return 0
            fi
            ;;
        application/x-sqlite3|application/vnd.sqlite3)
            if has_cmd "sqlite3"; then
                echo -e "${CYAN}Schema:${RESET}"
                sqlite3 "$file" ".schema" 2>/dev/null || echo -e "${RED}Failed to read SQLite database${RESET}"
                echo ""
                echo -e "${CYAN}Tables:${RESET}"
                sqlite3 "$file" ".tables" 2>/dev/null || true
                return 0
            fi
            ;;
    esac

    # Fallback: use file command with detailed output
    file -b "$file"
}

# Run main
main "$@"
