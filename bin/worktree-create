#!/usr/bin/env python3
"""
worktree-create - Create a git worktree with optional project-specific setup

Usage: worktree-create <branch-name> [base-branch]

Works with both existing and new branches.
Creates a worktree in .worktrees/ with:
- Basic git worktree setup for any repo
- Copied secrets from main checkout (if .secrets exists)
- Lookout-specific setup (if Lookout repo detected):
  - Lightweight venv using --system-site-packages
  - Editable installs of lookout_cli and lookout_config
  - Auto-configured .envrc for direnv
"""

import sys
import subprocess
import shutil
from pathlib import Path
from typing import Tuple


def main() -> int:
    """Main entry point."""
    # Parse arguments
    if len(sys.argv) < 2:
        print("Usage: worktree-create <branch-name> [base-branch]")
        print("")
        print("Examples:")
        print("  worktree-create feature-xyz          # Create new branch from main")
        print("  worktree-create hotfix-123 develop   # Create new branch from develop")
        print("  worktree-create existing-branch      # Move existing branch to worktree")
        return 1

    branch_name = sys.argv[1]
    base_branch = sys.argv[2] if len(sys.argv) > 2 else "main"

    try:
        # Get repository root
        repo_root = get_repo_root()

        # Check if this is a Lookout repository
        is_lookout = is_lookout_repo(repo_root)

        # Determine worktree path
        worktree_path = repo_root / ".worktrees" / branch_name

        if worktree_path.exists():
            print(f"Error: Worktree already exists at {worktree_path}")
            return 1

        print(f"Creating worktree for branch '{branch_name}'...")
        if is_lookout:
            print("Detected Lookout repository - setting up Python environment...")

        # Create the worktree
        create_worktree(repo_root, branch_name, base_branch, worktree_path)

        # Setup Lookout-specific environment if detected
        if is_lookout:
            setup_lookout_env(worktree_path, repo_root)

        # Copy secrets if they exist (universal behavior)
        copy_secrets(repo_root, worktree_path)

        # Print success message
        print("")
        print(f"âœ“ Worktree ready at: {worktree_path}")
        print("")
        print("To start working:")
        print(f"  cd {worktree_path}")
        if is_lookout:
            print("  # direnv will auto-configure the environment")
            print("  lookout up")
        print("")
        print("To remove this worktree later:")
        print(f"  git worktree remove {worktree_path}")

        return 0

    except subprocess.CalledProcessError as e:
        print(f"Error: Git command failed: {e}", file=sys.stderr)
        return 1
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        return 1


def get_repo_root() -> Path:
    """Get git repository root using git rev-parse."""
    result = subprocess.run(
        ["git", "rev-parse", "--show-toplevel"],
        capture_output=True,
        text=True,
        check=True
    )
    return Path(result.stdout.strip())


def is_lookout_repo(repo_root: Path) -> bool:
    """Check if repo has Lookout-specific directories."""
    return (
        (repo_root / "tools" / "lookout_cli").is_dir() and
        (repo_root / "packages" / "lookout_config").is_dir()
    )


def create_worktree(repo_root: Path, branch: str, base: str, worktree_path: Path) -> None:
    """Create git worktree for branch."""
    # Check if branch already exists
    result = subprocess.run(
        ["git", "show-ref", "--verify", "--quiet", f"refs/heads/{branch}"],
        cwd=repo_root,
        capture_output=True
    )
    branch_exists = result.returncode == 0

    if branch_exists:
        print(f"Branch '{branch}' exists, checking it out...")
        subprocess.run(
            ["git", "worktree", "add", str(worktree_path), branch],
            cwd=repo_root,
            check=True
        )
    else:
        print(f"Creating new branch '{branch}' from '{base}'...")
        subprocess.run(
            ["git", "worktree", "add", str(worktree_path), "-b", branch, base],
            cwd=repo_root,
            check=True
        )


def setup_lookout_env(worktree_path: Path, repo_root: Path) -> None:
    """Setup venv, install packages, configure direnv."""
    print("Setting up Python virtual environment...")

    # Create venv with system site packages
    subprocess.run(
        [sys.executable, "-m", "venv", "--system-site-packages", "./lookout"],
        cwd=worktree_path,
        check=True
    )

    print("Installing editable packages...")
    pip_path = worktree_path / "lookout" / "bin" / "pip"

    subprocess.run(
        [str(pip_path), "install", "-q", "-e", "./tools/lookout_cli"],
        cwd=worktree_path,
        check=True
    )
    subprocess.run(
        [str(pip_path), "install", "-q", "-e", "./packages/lookout_config"],
        cwd=worktree_path,
        check=True
    )

    print("Configuring direnv...")

    # Create .envrc
    envrc_content = """# Auto-generated by worktree-create
# Points lookout CLI wrapper to this worktree's venv
export LOOKOUT_VENV_PATH="$(pwd)/lookout"

# Optional: Auto-activate venv when entering directory
# Uncomment if you want automatic venv activation
# source lookout/bin/activate
"""
    (worktree_path / ".envrc").write_text(envrc_content)

    # Allow direnv for this directory
    subprocess.run(
        ["direnv", "allow", "."],
        cwd=worktree_path,
        check=True
    )


def copy_secrets(repo_root: Path, worktree_path: Path) -> None:
    """Copy .secrets directory if exists."""
    secrets_src = repo_root / ".secrets"
    if secrets_src.is_dir():
        print("Copying secrets...")
        secrets_dst = worktree_path / ".secrets"
        secrets_dst.mkdir(exist_ok=True)

        # Copy all contents from source to destination
        for item in secrets_src.iterdir():
            if item.is_dir():
                shutil.copytree(item, secrets_dst / item.name, dirs_exist_ok=True)
            else:
                shutil.copy2(item, secrets_dst / item.name)


if __name__ == "__main__":
    sys.exit(main())
