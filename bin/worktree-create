#!/usr/bin/env python3
"""Create a git worktree with optional project-specific setup.

Works with both existing and new branches.
Creates a worktree in .worktrees/ with:
- Basic git worktree setup for any repo
- Copied secrets from main checkout (if .secrets exists)
- Lookout-specific setup (if Lookout repo detected):
  - Lightweight venv using --system-site-packages
  - Editable installs of lookout_cli and lookout_config
  - Auto-configured .envrc for direnv
"""
import argparse
import shutil
import subprocess
import sys
from pathlib import Path

# Constants
WORKTREES_DIR = ".worktrees"
LOOKOUT_CLI_PATH = "tools/lookout_cli"
LOOKOUT_CONFIG_PATH = "packages/lookout_config"
SECRETS_DIR = ".secrets"


def parse_args() -> argparse.Namespace:
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="Create a git worktree with optional project-specific setup",
        epilog="""
examples:
  %(prog)s feature-xyz          # Create new branch from main
  %(prog)s hotfix-123 develop   # Create new branch from develop
  %(prog)s existing-branch      # Move existing branch to worktree
        """,
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )
    parser.add_argument(
        "branch_name",
        help="Name of the branch to create or checkout",
    )
    parser.add_argument(
        "base_branch",
        nargs="?",
        default="main",
        help="Base branch to create from (default: %(default)s)",
    )
    return parser.parse_args()


def main() -> int:
    """Main entry point."""
    args = parse_args()
    branch_name = args.branch_name
    base_branch = args.base_branch

    try:
        # Get repository root
        repo_root = get_repo_root()

        # Check if this is a Lookout repository
        is_lookout = is_lookout_repo(repo_root)

        # Determine worktree path (slugify branch name for directory)
        dir_name = branch_name.replace("/", "-")
        worktree_path = repo_root / WORKTREES_DIR / dir_name

        if worktree_path.exists():
            print(f"Error: Worktree already exists at {worktree_path}", file=sys.stderr)
            return 1

        print(f"Creating worktree for branch '{branch_name}'...")
        if is_lookout:
            print("Detected Lookout repository - setting up Python environment...")

        # Create the worktree
        create_worktree(repo_root, branch_name, base_branch, worktree_path)

        # Setup Lookout-specific environment if detected
        if is_lookout:
            setup_lookout_env(worktree_path, repo_root)

        # Copy secrets if they exist (universal behavior)
        copy_secrets(repo_root, worktree_path)

        # Print success message
        print("")
        print(f"âœ“ Worktree ready at: {worktree_path}")
        print("")
        print("To start working:")
        print(f"  cd {worktree_path}")
        if is_lookout:
            print("  # direnv will auto-configure the environment")
            print("  lookout up")
        print("")
        print("To remove this worktree later:")
        print(f"  git worktree remove {worktree_path}")

        return 0

    except subprocess.CalledProcessError as e:
        print(f"Error: Git command failed: {e}", file=sys.stderr)
        return 1
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        return 1


def get_repo_root() -> Path:
    """Get git repository root using git rev-parse.

    Returns:
        Path to the git repository root directory.

    Raises:
        subprocess.CalledProcessError: If not in a git repository.
    """
    result = subprocess.run(
        ["git", "rev-parse", "--show-toplevel"],
        capture_output=True,
        text=True,
        check=True,
    )
    return Path(result.stdout.strip())


def is_lookout_repo(repo_root: Path) -> bool:
    """Check if repo has Lookout-specific directories.

    Args:
        repo_root: Path to the git repository root.

    Returns:
        True if both lookout_cli and lookout_config directories exist.
    """
    return (
        (repo_root / LOOKOUT_CLI_PATH).is_dir()
        and (repo_root / LOOKOUT_CONFIG_PATH).is_dir()
    )


def create_worktree(
    repo_root: Path, branch: str, base: str, worktree_path: Path
) -> None:
    """Create git worktree for branch.

    Args:
        repo_root: Path to the git repository root.
        branch: Name of the branch to create or checkout.
        base: Base branch to create new branch from.
        worktree_path: Path where the worktree should be created.

    Raises:
        subprocess.CalledProcessError: If git worktree command fails.
    """
    # Check if branch already exists
    result = subprocess.run(
        ["git", "show-ref", "--verify", "--quiet", f"refs/heads/{branch}"],
        cwd=repo_root,
        capture_output=True,
    )
    branch_exists = result.returncode == 0

    if branch_exists:
        print(f"Branch '{branch}' exists, checking it out...")
        subprocess.run(
            ["git", "worktree", "add", str(worktree_path), branch],
            cwd=repo_root,
            check=True,
        )
    else:
        print(f"Creating new branch '{branch}' from '{base}'...")
        subprocess.run(
            ["git", "worktree", "add", str(worktree_path), "-b", branch, base],
            cwd=repo_root,
            check=True,
        )


def setup_lookout_env(worktree_path: Path, repo_root: Path) -> None:
    """Setup Lookout-specific Python environment.

    Args:
        worktree_path: Path to the worktree directory.
        repo_root: Path to the git repository root (unused but kept for symmetry).

    Raises:
        subprocess.CalledProcessError: If venv creation, pip install, or direnv fails.
    """
    print("Setting up Python virtual environment...")
    venv_name = worktree_path.name

    # Create venv with system site packages
    subprocess.run(
        [sys.executable, "-m", "venv", "--system-site-packages", venv_name],
        cwd=worktree_path,
        check=True,
    )

    print("Installing editable packages...")
    pip_path = worktree_path / venv_name / "bin" / "pip"

    for package_path in [LOOKOUT_CLI_PATH, LOOKOUT_CONFIG_PATH]:
        subprocess.run(
            [str(pip_path), "install", "-q", "-e", f"./{package_path}"],
            cwd=worktree_path,
            check=True,
        )

    print("Configuring direnv...")

    # Create .envrc
    envrc_content = f"""# Auto-generated by worktree-create
# Points lookout CLI wrapper to this worktree's venv
export LOOKOUT_VENV_PATH="$(pwd)/{venv_name}"

# Optional: Auto-activate venv when entering directory
# Uncomment if you want automatic venv activation
# source {venv_name}/bin/activate
"""
    (worktree_path / ".envrc").write_text(envrc_content)

    # Allow direnv for this directory
    subprocess.run(
        ["direnv", "allow", "."],
        cwd=worktree_path,
        check=True,
    )


def copy_secrets(repo_root: Path, worktree_path: Path) -> None:
    """Copy .secrets directory from repo root to worktree if it exists.

    Args:
        repo_root: Path to the git repository root.
        worktree_path: Path to the worktree directory.
    """
    secrets_src = repo_root / SECRETS_DIR
    if secrets_src.is_dir():
        print("Copying secrets...")
        secrets_dst = worktree_path / SECRETS_DIR
        secrets_dst.mkdir(exist_ok=True)

        # Copy all contents from source to destination
        for item in secrets_src.iterdir():
            if item.is_dir():
                shutil.copytree(item, secrets_dst / item.name, dirs_exist_ok=True)
            else:
                shutil.copy2(item, secrets_dst / item.name)


if __name__ == "__main__":
    sys.exit(main())
